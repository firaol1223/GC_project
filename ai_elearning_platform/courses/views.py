# ai_elearning_platform/courses/views.py
from django.shortcuts import render, get_object_or_404, redirect # redirect is needed
from django.contrib.auth.decorators import login_required
from django.http import HttpResponseForbidden, JsonResponse # JsonResponse for AJAX later
from django.views.decorators.http import require_POST # To ensure this view only accepts POST
from django.contrib import messages
from .models import *
from core.ai_utils import get_saq_feedback
from django.db import transaction
from users.models import *
from django.db.models import Count
from django.db.models import Q
from .forms import CourseReviewForm
from django.db.models import Avg
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
import re
from django.http import Http404

def is_instructor(user):
    """
    Determines if a user is an instructor based on the is_staff flag.
    """
    return user.is_authenticated and user.is_staff
# courses/views.py
# ... (existing imports: login_required, get_object_or_404, redirect, messages, Course)
from .forms import CourseForm # Import your new CourseForm
# from .utils import is_instructor # Your helper function

@login_required
def create_course_view(request):
    if not is_instructor(request.user): # Your instructor check
        messages.error(request, "You do not have permission to create courses.")
        return redirect('core:home')

    if request.method == 'POST':
        form = CourseForm(request.POST, request.FILES)
        if form.is_valid():
            course = form.save(commit=False)
            course.instructor = request.user # Assign the logged-in instructor
            course.save() # Slug will be auto-generated by model's save method
            messages.success(request, f"Course '{course.title}' created successfully! You can now add modules and lessons.")
            # Redirect to a page where they can manage the content of this new course,
            # or back to instructor dashboard. For now, let's go to instructor dashboard.
            # Ideally, redirect to an "edit course content" page for this new course.
            return redirect('courses:instructor_dashboard') 
            # Or: return redirect('courses:edit_course_content', course_slug=course.slug) # If you create such a page
    else:
        form = CourseForm()

    context = {
        'form': form,
        'page_title': "Create New Course"
    }
    return render(request, 'courses/course_form.html', context)


@login_required
def edit_course_view(request, course_slug):
    if not is_instructor(request.user):
        messages.error(request, "You do not have permission to edit courses.")
        return redirect('core:home')
    
    course = get_object_or_404(Course, slug=course_slug, instructor=request.user) # Ensure instructor owns course

    if request.method == 'POST':
        form = CourseForm(request.POST, request.FILES, instance=course)
        if form.is_valid():
            updated_course = form.save()
            messages.success(request, f"Course '{updated_course.title}' updated successfully.")
            return redirect('courses:instructor_dashboard') # Or course detail, or edit course content
            # Or: return redirect('courses:edit_course_content', course_slug=updated_course.slug)
    else:
        form = CourseForm(instance=course)

    context = {
        'form': form,
        'course': course, # Pass course for context, e.g., for title or "Edit <course_title>"
        'page_title': f"Edit Course: {course.title}"
    }
    return render(request, 'courses/course_form.html', context) # Reuse the same template
@login_required
def instructor_course_student_progress_view(request, course_slug):
    if not is_instructor(request.user): # Use your existing is_instructor check
        messages.error(request, "You do not have permission to view this page.")
        return redirect('core:home')

    course = get_object_or_404(Course, slug=course_slug, instructor=request.user) # Ensure instructor owns course
    
    # Get all unique users who have made any progress in this course
    students_with_progress_ids = UserLessonProgress.objects.filter(
        lesson__module__course=course
    ).values_list('user_id', flat=True).distinct()

    # Get CustomUser objects for these students
    # from django.contrib.auth import get_user_model
    # CustomUser = get_user_model()
    # students = CustomUser.objects.filter(id__in=students_with_progress_ids).select_related('profile')
    # OR, if you prefer to fetch profiles directly and then access user:
    from users.models import Profile as UserProfile # Renaming to avoid confusion if User is also imported
    students_profiles = UserProfile.objects.filter(user_id__in=students_with_progress_ids).select_related('user')


    student_progress_data = []
    total_lessons_in_course = Lesson.objects.filter(module__course=course).count()

    for profile in students_profiles:
        student_user = profile.user
        completed_by_this_student = UserLessonProgress.objects.filter(
            user=student_user,
            lesson__module__course=course
        ).count()
        
        progress_percent = 0
        if total_lessons_in_course > 0:
            progress_percent = round((completed_by_this_student / total_lessons_in_course) * 100)
        
        student_progress_data.append({
            'student_profile': profile, # Pass the whole profile object
            'student_user': student_user, # Pass the user object
            'completed_lessons': completed_by_this_student,
            'total_lessons': total_lessons_in_course,
            'progress_percent': progress_percent,
        })

    # Sort by progress (descending) or student name
    student_progress_data.sort(key=lambda x: x['student_user'].email) # Sort by email for example

    context = {
        'course': course,
        'student_progress_data': student_progress_data,
        'page_title': f"Student Progress for {course.title}"
    }
    return render(request, 'courses/instructor_course_student_progress.html', context)
@login_required
def instructor_dashboard_view(request):
    if not is_instructor(request.user): # Check if user is an instructor
        messages.error(request, "You do not have permission to view the instructor dashboard.")
        return redirect('core:home') # Or student dashboard if they are a student

    instructor = request.user

    # --- 1. Quick Stats ---
    courses_taught_qs = Course.objects.filter(instructor=instructor)
    total_courses_taught = courses_taught_qs.count()

    # Total unique students across all courses taught by this instructor
    # This can be complex if a student is in multiple courses by the same instructor.
    # We want unique students across all their courses.
    enrolled_student_ids = set()
    for course in courses_taught_qs:
        student_ids_in_course = UserLessonProgress.objects.filter(
            lesson__module__course=course
        ).values_list('user_id', flat=True).distinct()
        enrolled_student_ids.update(student_ids_in_course)
    total_unique_students = len(enrolled_student_ids)
    
    # Average completion rate for their courses (weighted by number of students perhaps, or simple average)
    # For simplicity, let's do a simple average of course average progresses
    course_average_progress_sum = 0
    courses_with_students_count = 0

    # --- 2. "My Courses" List with Stats ---
    my_courses_data = []
    for course in courses_taught_qs.annotate(num_lessons=Count('modules__lessons', distinct=True)).select_related('category'):
        students_in_this_course_ids = UserLessonProgress.objects.filter(
            lesson__module__course=course
        ).values_list('user_id', flat=True).distinct()
        num_students_in_this_course = len(students_in_this_course_ids)

        course_avg_progress_individual = 0
        if num_students_in_this_course > 0 and course.num_lessons > 0:
            total_progress_this_course = 0
            for student_id in students_in_this_course_ids:
                completed_by_student = UserLessonProgress.objects.filter(
                    user_id=student_id,
                    lesson__module__course=course
                ).count()
                total_progress_this_course += (completed_by_student / course.num_lessons) * 100
            course_avg_progress_individual = total_progress_this_course / num_students_in_this_course
            
            course_average_progress_sum += course_avg_progress_individual # For overall average
            courses_with_students_count += 1
        
        review_stats = course.reviews.aggregate(
            avg_rating=Avg('rating'), 
            num_reviews=Count('id')
        )

        my_courses_data.append({
            'course': course,
            'num_students': num_students_in_this_course,
            'average_progress': round(course_avg_progress_individual, 1),
            'avg_rating': round(review_stats['avg_rating'], 1) if review_stats['avg_rating'] else None,
            'num_reviews': review_stats['num_reviews'],
        })

    overall_instructor_course_avg_progress = 0
    if courses_with_students_count > 0:
        overall_instructor_course_avg_progress = round(course_average_progress_sum / courses_with_students_count, 1)

    # --- 3. Recent Activity (Placeholders for now) ---
    # recent_enrollments = ... (e.g., UserLessonProgress created_at for first lesson in their courses)
    # pending_quiz_reviews = UserAnswer.objects.filter(question__quiz__lesson__module__course__instructor=instructor, needs_review=True).count()

    context = {
        'total_courses_taught': total_courses_taught,
        'total_unique_students': total_unique_students,
        'overall_instructor_course_avg_progress': overall_instructor_course_avg_progress,
        # 'pending_quiz_reviews': pending_quiz_reviews,
        'my_courses_data': my_courses_data,
        'page_title': "Instructor Dashboard"
    }
    return render(request, 'courses/instructor_dashboard.html', context)
def course_list_view(request):
    # Annotate courses with their average rating and review count
    all_courses_qs = Course.objects.annotate(
        avg_rating=Avg('reviews__rating'),
        num_reviews=Count('reviews')
    ).select_related('category', 'instructor__profile').order_by('-created_at') # Or by avg_rating, etc.
    
    search_query = request.GET.get('q', '')
    if search_query:
        all_courses_qs = all_courses_qs.filter(
            Q(title__icontains=search_query) | 
            Q(description__icontains=search_query) |
            Q(category__name__icontains=search_query) |
            Q(instructor__first_name__icontains=search_query) |
            Q(instructor__last_name__icontains=search_query) |
            Q(instructor__email__icontains=search_query)
        ).distinct()
    
    page_number = request.GET.get('page', 1)
    paginator = Paginator(all_courses_qs, 9)

    try:
        courses_page = paginator.page(page_number)
    except PageNotAnInteger:
        courses_page = paginator.page(1)
    except EmptyPage:
        courses_page = paginator.page(paginator.num_pages)

    categories = CourseCategory.objects.annotate(num_cat_courses=Count('courses')).filter(num_cat_courses__gt=0) # Renamed to avoid clash
    
    context = {
        'courses': courses_page, 
        'categories': categories,
        'search_query': search_query, 
        'page_title': "Our Courses" if not search_query else f"Search Results for '{search_query}'"
    }
    return render(request, 'courses/course_list.html', context)


def course_list_by_category_view(request, category_slug):
    category = get_object_or_404(CourseCategory, slug=category_slug)
    # Annotate courses within the category as well
    all_courses_in_category = Course.objects.filter(category=category).annotate(
        avg_rating=Avg('reviews__rating'),
        num_reviews=Count('reviews')
    ).select_related('instructor__profile').order_by('-created_at')
    
    # ... (search and pagination logic similar to course_list_view) ...
    search_query = request.GET.get('q', '')
    if search_query:
        all_courses_in_category = all_courses_in_category.filter(
             Q(title__icontains=search_query) | 
             Q(description__icontains=search_query)
        ).distinct()

    page_number = request.GET.get('page', 1)
    paginator = Paginator(all_courses_in_category, 9)

    try:
        courses_page = paginator.page(page_number)
    except PageNotAnInteger:
        courses_page = paginator.page(1)
    except EmptyPage:
        courses_page = paginator.page(paginator.num_pages)
    
    categories = CourseCategory.objects.annotate(num_cat_courses=Count('courses')).filter(num_cat_courses__gt=0)
    context = {
        'courses': courses_page,
        'categories': categories,
        'current_category': category,
        'search_query': search_query,
        'page_title': f"Courses in {category.name}" if not search_query else f"Search in {category.name} for '{search_query}'"
    }
    return render(request, 'courses/course_list.html', context)


def course_detail_view(request, course_slug):
    # Fetch course with related modules, lessons, reviews, and instructor
    course = get_object_or_404(
        Course.objects.prefetch_related(
            'modules__lessons',
            'reviews__user__profile'
        ).select_related('instructor__profile', 'category'),
        slug=course_slug
    )

    # Initialize variables
    is_enrolled = False
    completed_lessons_for_course_count = 0
    course_progress_percent = 0
    first_uncompleted_lesson = None
    user_can_review = False
    existing_review_by_user = None
    review_form = None
    lesson_unlock_status = {}

    # Get all lessons for this course, ordered globally for unlock logic
    all_course_lessons_ordered = list(
        Lesson.objects.filter(module__course=course).order_by('module__order', 'order')
    )
    total_lessons_in_course = len(all_course_lessons_ordered)
    completed_lessons_ids_for_course = set()

    if request.user.is_authenticated:
        # Check if user is enrolled (has any progress in the course)
        is_enrolled = UserLessonProgress.objects.filter(
            user=request.user,
            lesson__module__course=course
        ).exists()

        # Get completed lesson IDs
        completed_lessons_ids_for_course = set(
            UserLessonProgress.objects.filter(
                user=request.user,
                lesson__module__course=course
            ).values_list('lesson_id', flat=True)
        )
        completed_lessons_for_course_count = len(completed_lessons_ids_for_course)

        # Calculate course progress percentage
        if total_lessons_in_course > 0:
            course_progress_percent = round(
                (completed_lessons_for_course_count / total_lessons_in_course) * 100
            )

        # Determine unlock status and first uncompleted lesson
        previous_lesson_passed_or_no_quiz = True  # First lesson is implicitly unlocked
        for lesson_obj in all_course_lessons_ordered:
            if previous_lesson_passed_or_no_quiz:
                lesson_unlock_status[lesson_obj.id] = True
                if lesson_obj.id not in completed_lessons_ids_for_course and first_uncompleted_lesson is None:
                    first_uncompleted_lesson = lesson_obj
            else:
                lesson_unlock_status[lesson_obj.id] = False

            # Update for next iteration: a lesson is complete if UserLessonProgress exists
            # Note: UserLessonProgress is only created for quiz-gated lessons after passing the quiz
            current_lesson_is_truly_complete = lesson_obj.id in completed_lessons_ids_for_course
            previous_lesson_passed_or_no_quiz = current_lesson_is_truly_complete

        # Review logic
        existing_review_by_user = CourseReview.objects.filter(
            course=course, user=request.user
        ).first()
        MIN_PROGRESS_TO_REVIEW = getattr(settings, 'MIN_COURSE_PROGRESS_PERCENT_TO_REVIEW', 0)

        can_review_based_on_progress = (
            course_progress_percent >= MIN_PROGRESS_TO_REVIEW if total_lessons_in_course > 0 else False
        )
        if is_enrolled and not existing_review_by_user and can_review_based_on_progress:
            user_can_review = True
            review_form = CourseReviewForm()
        elif is_enrolled and not can_review_based_on_progress and not existing_review_by_user:
            messages.info(
                request,
                f"Complete at least {MIN_PROGRESS_TO_REVIEW}% of this course to leave a review."
            )

    # Prepare modules_with_progress for template
    modules_with_progress = []
    for module in course.modules.all():
        module_total_lessons = 0
        module_lessons_with_status = []
        module_completed_lessons_count = 0

        # Filter lessons for this module, maintaining order
        current_module_lessons = [l for l in all_course_lessons_ordered if l.module_id == module.id]
        module_total_lessons = len(current_module_lessons)

        for lesson in current_module_lessons:
            is_lesson_completed_flag = (
                lesson.id in completed_lessons_ids_for_course if request.user.is_authenticated else False
            )
            is_unlocked_flag = lesson_unlock_status.get(
                lesson.id,
                True if not request.user.is_authenticated and all_course_lessons_ordered and lesson.id == all_course_lessons_ordered[0].id else False
            )

            if is_lesson_completed_flag:
                module_completed_lessons_count += 1

            module_lessons_with_status.append({
                'lesson': lesson,
                'is_completed': is_lesson_completed_flag,
                'is_unlocked': is_unlocked_flag,
                'is_manually_completable': (
                    lesson.is_manually_completable_by_user(request.user)
                    if request.user.is_authenticated
                    else False
                )
            })

        module_prog_perc = 0
        if request.user.is_authenticated and module_total_lessons > 0:
            module_prog_perc = round((module_completed_lessons_count / module_total_lessons) * 100)

        modules_with_progress.append({
            'module': module,
            'lessons_with_status': module_lessons_with_status,
            'completed_count': module_completed_lessons_count if request.user.is_authenticated else 0,
            'total_lessons': module_total_lessons,
            'progress_percent': module_prog_perc
        })

    # Reviews and Rating
    reviews = course.reviews.all()
    average_rating_data = reviews.aggregate(avg_rating=Avg('rating'), count_reviews=Count('id'))
    average_rating = round(average_rating_data['avg_rating'], 1) if average_rating_data['avg_rating'] is not None else None
    total_reviews_count = average_rating_data['count_reviews']
    total_students_enrolled = UserLessonProgress.objects.filter(
        lesson__module__course=course
    ).values('user').distinct().count()

    context = {
        'course': course,
        'modules_with_progress': modules_with_progress,
        'is_enrolled': is_enrolled,
        'total_lessons_in_course': total_lessons_in_course,
        'completed_lessons_in_course_count': completed_lessons_for_course_count,
        'course_progress_percent': course_progress_percent,
        'first_uncompleted_lesson': first_uncompleted_lesson,
        'reviews': reviews,
        'average_rating': average_rating,
        'total_reviews_count': total_reviews_count,
        'user_can_review': user_can_review,
        'existing_review': existing_review_by_user,
        'review_form': review_form,
        'page_title': course.title,
        'total_students_enrolled': total_students_enrolled,
        'MIN_PROGRESS_TO_REVIEW': getattr(settings, 'MIN_COURSE_PROGRESS_PERCENT_TO_REVIEW', 0)
    }
    return render(request, 'courses/course_detail.html', context)
# View to display a single lesson's content

# courses/views.py
# ... (imports) ...
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, render
from .models import Course, Lesson, UserLessonProgress

# courses/views.py
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, redirect, render
from .models import Course, Lesson, Module, UserLessonProgress, CourseReview, CourseCategory, Quiz, UserQuizAttempt

@login_required
def lesson_detail_view(request, course_slug, lesson_slug):
    # Fetch course and lesson
    course = get_object_or_404(Course, slug=course_slug)
    lesson = get_object_or_404(
        Lesson.objects.select_related('module__course').prefetch_related('contents'),
        slug=lesson_slug,
        module__course=course
    )

    # Get all lessons in the course for unlock logic, ordered globally
    all_course_lessons_ordered = list(
        Lesson.objects.filter(module__course=course).order_by('module__order', 'order')
    )

    # --- Lesson Access Control ---
    is_unlocked_for_user = False
    if all_course_lessons_ordered:
        if lesson.id == all_course_lessons_ordered[0].id:
            # First lesson is always unlocked
            is_unlocked_for_user = True
        else:
            # Find the index of the current lesson
            lesson_index = next(
                (i for i, l in enumerate(all_course_lessons_ordered) if l.id == lesson.id),
                None
            )
            if lesson_index is not None and lesson_index > 0:
                # Check if the previous lesson is completed
                previous_lesson = all_course_lessons_ordered[lesson_index - 1]
                is_unlocked_for_user = UserLessonProgress.objects.filter(
                    user=request.user, lesson=previous_lesson
                ).exists()

    if not is_unlocked_for_user:
        # Redirect with error if lesson is not accessible
        messages.error(request, "You must complete the previous lesson to access this one.")
        return redirect('courses:course_detail', course_slug=course.slug)

    # Get lesson contents, previous, and next lessons
    contents = lesson.contents.all().order_by('order')
    previous_lesson = lesson.get_previous_lesson()
    next_lesson = lesson.get_next_lesson()

    # --- Quiz Status for this Lesson (if it has one) ---
    lesson_quiz = None
    user_quiz_attempt_info = {
        'has_attempted': False,
        'passed_latest': False,
        'can_retake': False,
        'latest_attempt_id': None,
        'attempts_left_message': ''
    }

    if lesson.has_quiz():  # Method on Lesson model
        lesson_quiz = lesson.quiz  # Access the related Quiz object
        latest_attempt = UserQuizAttempt.objects.filter(
            user=request.user, 
            quiz=lesson_quiz
        ).order_by('-completed_at').first()

        if latest_attempt:
            user_quiz_attempt_info['has_attempted'] = True
            user_quiz_attempt_info['passed_latest'] = latest_attempt.passed if latest_attempt.passed is not None else False
            user_quiz_attempt_info['latest_attempt_id'] = latest_attempt.id

            if not user_quiz_attempt_info['passed_latest']:
                user_attempts_count = UserQuizAttempt.objects.filter(user=request.user, quiz=lesson_quiz).count()
                if lesson_quiz.max_attempts == 0 or user_attempts_count < lesson_quiz.max_attempts:
                    user_quiz_attempt_info['can_retake'] = True
                    if lesson_quiz.max_attempts > 0:
                        attempts_left = lesson_quiz.max_attempts - user_attempts_count
                        user_quiz_attempt_info['attempts_left_message'] = f"({attempts_left} attempt{'s' if attempts_left != 1 else ''} left)"
                else:  # Max attempts reached and not passed
                    user_quiz_attempt_info['attempts_left_message'] = "(Max attempts reached)"

    # Determine completion status
    is_already_marked_complete = UserLessonProgress.objects.filter(user=request.user, lesson=lesson).exists()
    
    # Determine if "Mark as Complete" button should be shown
    can_manually_mark_complete = False
    if not lesson.has_quiz():  # If no quiz, can be marked manually
        can_manually_mark_complete = True
    elif user_quiz_attempt_info['passed_latest']:  # If has quiz and latest attempt was a pass
        can_manually_mark_complete = True
        # Ensure lesson is marked complete if quiz is passed (for consistency with submit_quiz_view)
        if not is_already_marked_complete and user_quiz_attempt_info['passed_latest']:
            UserLessonProgress.objects.get_or_create(user=request.user, lesson=lesson)
            is_already_marked_complete = True  # Update after creation

    context = {
        'course': course,
        'lesson': lesson,
        'contents': contents,
        'current_module': lesson.module,
        'previous_lesson': previous_lesson,
        'next_lesson': next_lesson,
        'is_unlocked_for_user': is_unlocked_for_user,
        'can_manually_mark_complete': can_manually_mark_complete and not is_already_marked_complete,
        'is_already_marked_complete': is_already_marked_complete,
        'lesson_quiz': lesson_quiz,
        'user_quiz_attempt_info': user_quiz_attempt_info,
        'lesson_completed': is_already_marked_complete,  # For backward compatibility with template
    }
    return render(request, 'courses/lesson_detail.html', context)

# Placeholder for enrollment view - we'll keep it simple for now
@login_required
def enroll_course_view(request, course_slug): # This view is currently a placeholder
    course = get_object_or_404(Course, slug=course_slug)

    # Check if user has already made any progress in this course
    already_started = UserLessonProgress.objects.filter(
        user=request.user,
        lesson__module__course=course
    ).exists()

    if already_started:
        messages.info(request, f"You are already making progress in '{course.title}'. Keep it up!")
    else:
        # This is where a real Enrollment object would be created.
        # For now, the first lesson completion will "enroll" them for tracking.
        messages.success(request, f"Great choice! You're ready to start '{course.title}'. Dive into the first lesson!")
        # Optionally, redirect to the first lesson of the course if it exists
        first_lesson = Lesson.objects.filter(module__course=course).order_by('module__order', 'order').first()
        if first_lesson:
            return redirect('courses:lesson_detail', course_slug=course.slug, lesson_slug=first_lesson.slug)

    return redirect('courses:course_detail', course_slug=course.slug)

# courses/views.py
# ... (imports: Course, Lesson, UserLessonProgress, Certificate, messages, etc.) ...

@login_required
@require_POST
def mark_lesson_completed_view(request, lesson_slug):
    lesson = get_object_or_404(Lesson.objects.select_related('module__course'), slug=lesson_slug)
    course = lesson.module.course
    user = request.user

    progress, created = UserLessonProgress.objects.get_or_create(user=user, lesson=lesson)

    if created:
        messages.success(request, f"Lesson '{lesson.title}' marked as completed!")
        # ... (your existing points awarding logic) ...
        # request.user.profile.award_points(...)

        # --- Check for Course Completion and Issue Certificate ---
        total_lessons_in_course = Lesson.objects.filter(module__course=course).count()
        completed_lessons_in_course = UserLessonProgress.objects.filter(user=user, lesson__module__course=course).count()

        if total_lessons_in_course > 0 and completed_lessons_in_course == total_lessons_in_course:
            # Course is completed!
            print(f"User {user.email} completed course {course.title}") # DEBUG

            # Check if a certificate already exists for this user and course
            if not Certificate.objects.filter(user=user, course=course).exists():
                # Issue a new certificate
                new_certificate = Certificate.objects.create(
                    user=user,
                    course=course
                    # Optional: Set user_name_on_certificate=user.get_full_name(), etc.
                )
                print(f"Certificate {new_certificate.certificate_id} issued to {user.email} for {course.title}") # DEBUG
                messages.success(request, f"Congratulations! You've completed the course '{course.title}' and earned a certificate!")
                
                # Optional: Trigger a notification for the certificate
                # from core.utils import create_notification (ensure no circular imports)
                # create_notification(
                #     recipient=user,
                #     verb='certificate_earned',
                #     message=f"You've earned a certificate for completing '{course.title}'!",
                #     link=reverse('users:student_dashboard') + '#certificates' # Link to certs on dashboard
                # )
            else:
                print(f"Certificate already exists for {user.email} for {course.title}") # DEBUG
                messages.info(request, f"You've completed '{course.title}'! Your certificate is available on your dashboard.")

            # ... (your existing course completion points/badge awarding logic) ...
    else:
        messages.info(request, f"Lesson '{lesson.title}' was already completed.")
    
    # Redirect back to the lesson or course detail page
    return redirect('courses:lesson_detail', course_slug=course.slug, lesson_slug=lesson.slug)
# courses/views.py
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import Quiz, Question, AnswerChoice, UserQuizAttempt # Ensure all are imported
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.admin.views.decorators import staff_member_required # Or a custom instructor permission
from django.contrib import messages
from django.urls import reverse
from django.db import transaction
from core.ai_utils import generate_quiz_questions_with_ai
@staff_member_required # Or a more specific permission for instructors
@transaction.atomic # Ensure all DB operations are atomic
def ai_generate_quiz_view(request, lesson_id=None): # Can be linked from a lesson, or standalone
    target_lesson = None
    source_content_for_ai = ""
    base_quiz_title = "AI Generated Quiz"

    if lesson_id:
        target_lesson = get_object_or_404(Lesson, pk=lesson_id)
        # Concatenate all text content from the lesson
        lesson_contents = target_lesson.contents.filter(content_type='text', text_content__isnull=False)
        source_content_for_ai = "\n\n".join([lc.text_content for lc in lesson_contents if lc.text_content])
        if not source_content_for_ai:
            messages.error(request, f"Lesson '{target_lesson.title}' has no text content to generate a quiz from.")
            return redirect(request.META.get('HTTP_REFERER', reverse('admin:courses_lesson_changelist')))
        base_quiz_title = f"Quiz for: {target_lesson.title}"
        print(f"Source content for AI (Lesson: {target_lesson.title}): {source_content_for_ai[:200]}...")


    # For simplicity, using fixed parameters. In a real app, get these from a form.
    num_mcq_to_generate = int(request.POST.get('num_mcq', 3)) # Get from POST or default
    num_saq_to_generate = int(request.POST.get('num_saq', 2))
    difficulty_level = request.POST.get('difficulty', 'medium')
    custom_quiz_title = request.POST.get('quiz_title', base_quiz_title)
    custom_topic = request.POST.get('custom_topic', None) # If generating from a topic instead of lesson content

    if request.method == 'POST': # Assuming parameters are POSTed or fixed for now
        if not source_content_for_ai and not custom_topic:
            messages.error(request, "Cannot generate quiz: No lesson content or custom topic provided.")
            return redirect(request.META.get('HTTP_REFERER', reverse('admin:index'))) # Sensible redirect

        # Use custom_topic if provided, otherwise use lesson title as a general topic hint
        topic_for_ai = custom_topic or (target_lesson.title if target_lesson else "General Knowledge")

        generated_data = generate_quiz_questions_with_ai(
            source_content=source_content_for_ai,
            num_mcq=num_mcq_to_generate,
            num_saq=num_saq_to_generate,
            difficulty=difficulty_level,
            topic=topic_for_ai
        )

        if isinstance(generated_data, dict) and "error" in generated_data:
            messages.error(request, f"AI Quiz Generation Failed: {generated_data['error']}")
        elif isinstance(generated_data, list) and generated_data:
            # Create a new Quiz
            new_quiz = Quiz.objects.create(
                title=custom_quiz_title, 
                lesson=target_lesson, # Link to lesson if generated from it
                description=f"AI-generated quiz on '{topic_for_ai}'. Difficulty: {difficulty_level}. Please review carefully.",
                is_ai_generated=True,
                source_text_for_ai=source_content_for_ai[:2000] if source_content_for_ai else None, # Store snippet
                generation_prompt_params={'num_mcq':num_mcq_to_generate, 'num_saq':num_saq_to_generate, 'difficulty':difficulty_level, 'topic':topic_for_ai}
            )
            print(f"Created new Quiz ID: {new_quiz.id} titled '{new_quiz.title}'")

            for q_order, q_data in enumerate(generated_data):
                question = Question.objects.create(
                    quiz=new_quiz,
                    question_text=q_data.get('question_text', 'Error: Missing question text'),
                    question_type=q_data.get('question_type', 'MCQ').upper(), # Ensure uppercase
                    points=q_data.get('points', 1),
                    explanation=q_data.get('explanation'), # Optional
                    order=q_order
                )
                print(f"  Created Question ID: {question.id}, Type: {question.question_type}")

                if question.question_type == 'MCQ':
                    choices = q_data.get('choices', [])
                    correct_answer_idx = q_data.get('correct_answer_index', -1)
                    for idx, choice_text in enumerate(choices):
                        AnswerChoice.objects.create(
                            question=question,
                            choice_text=choice_text,
                            is_correct=(idx == correct_answer_idx)
                        )
                        print(f"    Created Choice: '{choice_text}', Correct: {idx == correct_answer_idx}")
                elif question.question_type == 'SAQ':
                    # For SAQs, the 'ideal_answer' from AI could be stored in Question.explanation
                    # or a new field on Question model like `model_answer_for_saq`
                    question.explanation = q_data.get('ideal_answer') # Storing ideal answer in explanation for now
                    question.save(update_fields=['explanation'])
                    print(f"    SAQ Ideal Answer/Explanation set: {str(question.explanation)[:50]}...")
            
            messages.success(request, f"AI successfully generated a quiz with {len(generated_data)} questions for '{new_quiz.title}'. Please review and edit as needed.")
            return redirect(reverse('admin:courses_quiz_change', args=[new_quiz.id])) # Redirect to edit the new quiz
        else:
            messages.error(request, "AI Quiz Generation returned no questions or an unexpected format.")
        
        # Fallback redirect
        if target_lesson:
            return redirect(reverse('admin:courses_lesson_change', args=[target_lesson.id]))
        return redirect(reverse('admin:courses_quiz_changelist'))

    # For GET request, display a simple form to trigger generation (or integrate into admin)
    # This part would be a simple HTML form POSTing to this same view.
    # For now, this view primarily handles the POST logic from an admin action.
    context = {
        'lesson': target_lesson,
        'page_title': f"Generate AI Quiz for {target_lesson.title}" if target_lesson else "Generate AI Quiz from Topic"
        # 'form': AIQuizGenerationForm() # If using a Django form
    }
    return render(request, 'courses/admin/ai_generate_quiz_form.html', context) # A simple form template
@login_required
def quiz_detail_view(request, quiz_id):
    quiz = get_object_or_404(Quiz.objects.select_related('lesson__module__course') # For breadcrumbs if needed
                                 .prefetch_related('questions__choices'), 
                             pk=quiz_id)
    user = request.user

    # Get all attempts by the user for this quiz
    user_attempts = UserQuizAttempt.objects.filter(user=user, quiz=quiz).order_by('-completed_at')
    user_attempts_count = user_attempts.count()
    
    # Check if the user has already passed this quiz in any previous attempt
    passed_attempt = user_attempts.filter(passed=True).first() # Get the first (latest) passed attempt

    if passed_attempt:
        messages.success(request, f"You have already passed '{quiz.title}' with a score of {passed_attempt.score:.0f}%.")
        return redirect('courses:quiz_result', attempt_id=passed_attempt.id)

    # Check if max attempts have been reached AND they haven't passed
    if not passed_attempt and quiz.max_attempts > 0 and user_attempts_count >= quiz.max_attempts:
        messages.error(request, f"You have reached the maximum of {quiz.max_attempts} attempts for '{quiz.title}' and have not passed yet.")
        last_attempt = user_attempts.first() # Show result of the very last attempt
        if last_attempt:
            return redirect('courses:quiz_result', attempt_id=last_attempt.id)
        # If no attempts somehow (shouldn't happen if count >= max_attempts), redirect to course
        return redirect('courses:course_detail', course_slug=quiz.lesson.module.course.slug) if quiz.lesson else redirect('courses:course_list')

    # If none of the above, user can proceed to take/retake the quiz
    # (The submit_quiz_view will also do a final check on max_attempts before creating a new attempt)

    # Check if it's a retake and provide context
    is_retake = user_attempts_count > 0
    attempts_left_message = ""
    if quiz.max_attempts > 0:
        attempts_left = quiz.max_attempts - user_attempts_count
        if attempts_left <= 0 and not passed_attempt: # Should be caught above, but for clarity
            attempts_left_message = "No attempts left."
        elif attempts_left > 0:
            attempts_left_message = f"{attempts_left} attempt{'s' if attempts_left != 1 else ''} remaining."
    else: # Unlimited attempts
        attempts_left_message = "Unlimited attempts."


    if is_retake and not passed_attempt:
        messages.info(request, f"This is a retake for '{quiz.title}'. {attempts_left_message} Good luck!")
    elif quiz.max_attempts > 0 : # First attempt with limited retakes
         messages.info(request, f"You have {quiz.max_attempts} attempt(s) for this quiz. {attempts_left_message}")


    context = {
        'quiz': quiz,
        'questions': quiz.questions.all(), # questions are prefetched
        'is_retake': is_retake,
        'attempts_left_message': attempts_left_message,
        'page_title': f"Quiz: {quiz.title}"
    }
    return render(request, 'courses/quiz_detail.html', context)

    return redirect('courses:quiz_result', attempt_id=attempt.id)

@login_required
def quiz_result_view(request, attempt_id):
    print(f"--- QUIZ RESULT VIEW for Attempt ID: {attempt_id} ---")
    attempt = get_object_or_404(
        UserQuizAttempt.objects.select_related(
            'user__profile', 
            'quiz'
        ).prefetch_related(
            'user_answers__question__choices', 
            'user_answers__selected_choice'
        ),
        pk=attempt_id
    )

    # Permission check
    if not (request.user == attempt.user or request.user.is_staff):
        messages.error(request, "You do not have permission to view these results.")
        print(f"  User {request.user.email} doesn't have permission to view attempt {attempt_id}. Redirecting to home.")
        return redirect('users:student_dashboard' if request.user.is_authenticated else 'core:home')

    # Get ordered user answers
    user_answers_ordered = attempt.user_answers.all().order_by('question__order')
    print(f"  Found {user_answers_ordered.count()} UserAnswers for attempt {attempt_id}")
    
    # Check if the quiz has SAQs
    has_saq_in_quiz = attempt.quiz.questions.filter(question_type='SAQ').exists()
    print(f"  Does the original quiz {attempt.quiz.title} have SAQs? {has_saq_in_quiz}")

    # Calculate SAQs needing review
    saqs_requiring_review_count = attempt.user_answers.filter(
        question__question_type='SAQ', 
        needs_review=True
    ).count()
    print(f"  SAQs requiring review for this attempt: {saqs_requiring_review_count}")

    # Calculate the number of attempts by the user for this quiz
    user_attempts_count = attempt.quiz.attempts.filter(user=request.user).count()
    print(f"  User {request.user.email} has {user_attempts_count} attempts for quiz {attempt.quiz.title}")

    context = {
        'attempt': attempt,
        'quiz': attempt.quiz,
        'user_answers': user_answers_ordered,
        'has_saq': has_saq_in_quiz,
        'saqs_requiring_review_count': saqs_requiring_review_count,
        'user_attempts_count': user_attempts_count,  # Add to context
        'page_title': f"Results for {attempt.quiz.title}"
    }
    return render(request, 'courses/quiz_result.html', context)

 

@login_required
@require_POST
@transaction.atomic
def submit_quiz_view(request, quiz_id):
    # Fetch quiz with related lesson and questions/choices
    quiz = get_object_or_404(
        Quiz.objects.select_related('lesson').prefetch_related('questions__choices'),
        pk=quiz_id
    )
    user = request.user
    print(f"--- SUBMIT QUIZ (Gating Logic) - Quiz: {quiz.title}, User: {user.email} ---")

    # --- Check Max Attempts ---
    user_attempts_count = UserQuizAttempt.objects.filter(user=user, quiz=quiz).count()
    if quiz.max_attempts > 0 and user_attempts_count >= quiz.max_attempts:
        if UserQuizAttempt.objects.filter(user=user, quiz=quiz, passed=True).exists():
            messages.info(
                request,
                f"You have already passed this quiz. Further attempts are not allowed as you've reached the max of {quiz.max_attempts}."
            )
            last_passed_attempt = UserQuizAttempt.objects.filter(
                user=user, quiz=quiz, passed=True
            ).order_by('-score').first()
            return redirect('courses:quiz_result', attempt_id=last_passed_attempt.id)
        else:
            messages.error(
                request,
                f"You have reached the maximum of {quiz.max_attempts} attempts for this quiz and haven't passed yet."
            )
            last_attempt = UserQuizAttempt.objects.filter(
                user=user, quiz=quiz
            ).order_by('-completed_at').first()
            if last_attempt:
                return redirect('courses:quiz_result', attempt_id=last_attempt.id)
            return redirect(
                'courses:course_detail',
                course_slug=quiz.lesson.module.course.slug
            ) if quiz.lesson else redirect('courses:course_list')

    # Create new quiz attempt
    attempt = UserQuizAttempt.objects.create(user=user, quiz=quiz)
    print(f"New UserQuizAttempt created: ID {attempt.id} ...")

    # --- Variables for score calculation ---
    mcq_questions_count = 0
    mcq_correct_answers_count = 0
    saq_questions_count = 0
    saq_total_percentage_score_sum = 0
    saq_processed_for_scoring_count = 0
    any_saq_needs_review = False

    print(f"--- Starting Question Processing for Attempt ID: {attempt.id} ---")
    for question in quiz.questions.all():
        user_answer = UserAnswer(attempt=attempt, question=question)
        print(f"\nProcessing QID: {question.id}, Type: {question.question_type} ...")

        if question.question_type == 'MCQ':
            mcq_questions_count += 1
            form_field_name = f'question_{question.id}'
            selected_choice_id_str = request.POST.get(form_field_name)
            if selected_choice_id_str and selected_choice_id_str.strip():
                try:
                    choice_pk = int(selected_choice_id_str)
                    selected_choice_obj = AnswerChoice.objects.get(pk=choice_pk, question=question)
                    user_answer.selected_choice = selected_choice_obj
                    if selected_choice_obj.is_correct:
                        mcq_correct_answers_count += 1
                    print(f"    MCQ Choice: '{selected_choice_obj.choice_text}', Correct: {selected_choice_obj.is_correct}")
                except (AnswerChoice.DoesNotExist, ValueError) as e:
                    print(f"    Error processing MCQ choice: {e}")
            else:
                print(f"    MCQ: No choice submitted.")

        elif question.question_type == 'SAQ':
            saq_questions_count += 1
            saq_text = request.POST.get(f'question_{question.id}_saq_text', '').strip()
            user_answer.short_answer_text = saq_text
            print(f"  SAQ (QID {question.id}): User text: '{saq_text[:50]}...'")

            MIN_SAQ_LENGTH = getattr(settings, 'SAQ_MIN_LENGTH', 15)
            current_saq_ai_score_0_10 = None

            if saq_text and len(saq_text) >= MIN_SAQ_LENGTH:
                ai_raw_response = get_saq_feedback(question.question_text, saq_text)
                print(f"    Raw AI Response: '{ai_raw_response[:150]}...'")

                parsed_feedback = ai_raw_response
                needs_review_flag = True

                score_match = re.search(r"Preliminary Score:\s*(\d{1,2})/10", ai_raw_response, re.IGNORECASE)
                if score_match:
                    try:
                        ai_score_val = int(score_match.group(1))
                        if 0 <= ai_score_val <= 10:
                            current_saq_ai_score_0_10 = ai_score_val
                            user_answer.ai_score = current_saq_ai_score_0_10
                            needs_review_flag = ai_score_val < 4
                            parsed_feedback = re.sub(
                                r"Preliminary Score:.*", "", ai_raw_response, flags=re.IGNORECASE
                            ).strip()
                            print(f"      Parsed AI Score (0-10): {current_saq_ai_score_0_10}")
                        else:
                            print(f"      AI Score {ai_score_val} out of range. Flagging.")
                    except ValueError:
                        print(f"      ERROR: Could not convert parsed AI score. Flagging.")
                else:
                    print(f"      Score pattern not found in AI response. Flagging.")

                user_answer.feedback = parsed_feedback
                user_answer.needs_review = needs_review_flag
                if needs_review_flag:
                    any_saq_needs_review = True

            elif not saq_text:
                print(f"    SAQ: No answer. Setting AI score (0-10) to 0.")
                current_saq_ai_score_0_10 = 0
                user_answer.ai_score = 0
                user_answer.feedback = "No answer was provided."
                user_answer.needs_review = False
            else:
                print(f"    SAQ: Answer too short. Flagging. Setting AI score (0-10) to 0.")
                current_saq_ai_score_0_10 = 0
                user_answer.ai_score = 0
                user_answer.feedback = "Answer too short for AI evaluation."
                user_answer.needs_review = True
                any_saq_needs_review = True

            if current_saq_ai_score_0_10 is not None:
                saq_total_percentage_score_sum += (current_saq_ai_score_0_10 / 10) * 100
                saq_processed_for_scoring_count += 1

        user_answer.save()
        print(
            f"  Saved UserAnswer (ID: {user_answer.id}): "
            f"selected_choice_id='{user_answer.selected_choice_id}', "
            f"ai_score={user_answer.ai_score}, needs_review={user_answer.needs_review}"
        )

    # --- Calculate final attempt.score using Strategy 1 ---
    print(f"\n--- Final Score Calculation (Strategy 1) for Attempt ID: {attempt.id} ---")
    mcq_percentage = 0
    has_mcqs = mcq_questions_count > 0
    if has_mcqs:
        mcq_percentage = (mcq_correct_answers_count / mcq_questions_count) * 100
        print(f"MCQ Section: {mcq_correct_answers_count}/{mcq_questions_count} correct. Percentage: {mcq_percentage:.2f}%")

    saq_average_percentage = 0
    has_saqs_for_scoring = saq_processed_for_scoring_count > 0
    if has_saqs_for_scoring:
        saq_average_percentage = saq_total_percentage_score_sum / saq_processed_for_scoring_count
        print(
            f"SAQ Section: Average AI-assisted percentage: {saq_average_percentage:.2f}% "
            f"(based on {saq_processed_for_scoring_count} scored SAQs out of {saq_questions_count} total SAQs)"
        )
    elif saq_questions_count > 0:
        print(f"SAQ Section: No SAQs were scorable by AI. SAQ percentage considered 0 for now.")
        saq_average_percentage = 0
        any_saq_needs_review = True

    if has_mcqs and saq_questions_count > 0:
        if has_saqs_for_scoring:
            attempt.score = (mcq_percentage + saq_average_percentage) / 2
            print(f"  Combined Score (MCQ + SAQ Avg): {attempt.score:.2f}%")
        else:
            attempt.score = mcq_percentage
            print(f"  Combined Score (SAQs not scorable): {attempt.score:.2f}% (MCQ part only)")
            any_saq_needs_review = True
    elif has_mcqs:
        attempt.score = mcq_percentage
        print(f"  Only MCQs. Final Score: {attempt.score:.2f}%")
    elif saq_questions_count > 0:
        if has_saqs_for_scoring:
            attempt.score = saq_average_percentage
            print(f"  Only SAQs. Final Score: {attempt.score:.2f}%")
        else:
            attempt.score = 0
            print(f"  Only SAQs, but none scorable. Final Score set to 0.")
            any_saq_needs_review = True
    else:
        attempt.score = 0
        print(f"  Empty quiz. Score set to 0%.")

    # --- Determine if Quiz was Passed & Handle Lesson Completion ---
    if attempt.score is not None:
        if attempt.score >= quiz.pass_mark_percentage:
            attempt.passed = True
            messages.success(
                request,
                f"Congratulations! You passed '{quiz.title}' with a score of {attempt.score:.0f}%."
            )
            if quiz.lesson:
                lesson_progress, created = UserLessonProgress.objects.get_or_create(
                    user=user,
                    lesson=quiz.lesson,
                )
                if created:
                    print(f"  Lesson '{quiz.lesson.title}' marked complete due to passing quiz.")
                    # Optionally award points here if needed
                else:
                    print(f"  Lesson '{quiz.lesson.title}' was already marked complete.")
        else:
            attempt.passed = False
            messages.warning(
                request,
                f"You did not pass '{quiz.title}' (Score: {attempt.score:.0f}%). Required: {quiz.pass_mark_percentage}%."
            )
    else:
        attempt.passed = None  # Or False if defaulting to fail until reviewed
        messages.info(
            request,
            "Your quiz answers have been submitted. Final pass/fail status for lessons requiring this quiz will be determined after full grading."
        )
        any_saq_needs_review = True

    attempt.save()
    print(f"Saved UserQuizAttempt ID: {attempt.id} with final score: {attempt.score}, Passed: {attempt.passed}")

    # --- Determine user-facing messages ---
    if attempt.score is not None:
        score_display = f"{attempt.score:.0f}%"
        if any_saq_needs_review:
            messages.warning(
                request,
                f"Quiz submitted! Your preliminary score is {score_display}. Some short answers require instructor review, which may adjust your final grade."
            )
        else:
            messages.success(request, f"Quiz submitted! Your score is {score_display}.")
    else:
        messages.info(
            request,
            "Your quiz has been submitted. All short answers require instructor review for a final score."
        )

    return redirect('courses:quiz_result', attempt_id=attempt.id)
@login_required
@require_POST # Only allow POST requests for submitting reviews
def submit_course_review_view(request, course_slug):
    course = get_object_or_404(Course, slug=course_slug)
    
    # Check if user is "enrolled" (has made progress) - optional condition for reviewing
    # You might want to allow reviews only after some engagement.
    # has_progress = UserLessonProgress.objects.filter(user=request.user, lesson__module__course=course).exists()
    # if not has_progress:
    #     messages.error(request, "You need to engage with the course before reviewing.")
    #     return redirect('courses:course_detail', course_slug=course.slug)

    # Check if user has already reviewed this course
    if CourseReview.objects.filter(course=course, user=request.user).exists():
        messages.error(request, "You have already reviewed this course.")
        return redirect('courses:course_detail', course_slug=course.slug)

    form = CourseReviewForm(request.POST)
    if form.is_valid():
        review = form.save(commit=False)
        review.course = course
        review.user = request.user
        review.save()
        messages.success(request, "Thank you for your review!")
        # Optional: Update course.average_rating here if you denormalize
    else:
        # Handle form errors - pass them back to the course detail page
        # This is a bit tricky with a redirect. Better to handle form display on course_detail page itself.
        # For now, just a generic error. We'll improve this by integrating form into course_detail_view.
        for field, errors in form.errors.items():
            for error in errors:
                messages.error(request, f"{field.capitalize()}: {error}")
        print(f"Review form errors: {form.errors.as_json()}") # Debug

    return redirect('courses:course_detail', course_slug=course.slug)
# courses/views.py
# ... (imports) ...
# import uuid # Already imported for other views

def view_certificate_view(request, certificate_uuid):
    try:
        # Convert string from URL to UUID for lookup
        cert_uuid_obj = uuid.UUID(str(certificate_uuid))
        certificate = get_object_or_404(
            Certificate.objects.select_related('user__profile', 'course__instructor__profile'), 
            certificate_id=cert_uuid_obj
        )
    except ValueError: # If certificate_uuid is not a valid UUID format
        raise Http404("Invalid certificate ID format.")

    # Optional: Permission check - only owner or staff can view?
    # if not (request.user.is_authenticated and (request.user == certificate.user or request.user.is_staff)):
    #     messages.error(request, "You do not have permission to view this certificate.")
    #     return redirect('core:home') # Or some other appropriate page

    context = {
        'certificate': certificate,
        'page_title': f"Certificate: {certificate.course.title}"
    }
    # This template will be designed to look like a certificate
    return render(request, 'courses/certificate_detail_template.html', context)